{
  "language": "Solidity",
  "sources": {
    "Contracts/Store.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.21;\r\n\r\ncontract Store {\r\n    uint256 private totalSellers = 0;\r\n    uint256 private totalBuyers = 0;\r\n\r\n    //----- Structs -----\r\n\r\n    struct Product {\r\n        uint256 productID;\r\n        string productName;\r\n        address sellerAddress; // The product object has a sellerAddress reference\r\n        uint256 productPrice; //in wei\r\n        uint256 totalSold;\r\n        bool isExist; //flag to determin whether the product exists TODO: figure out a better way\r\n        uint256 numOfReviewsGiven;\r\n        uint256 review;\r\n    }\r\n\r\n    struct Transaction {\r\n        uint256 txnID;\r\n        uint256 timeStamp;\r\n        Product purchasedProduct;\r\n        bool reviewed;\r\n        bool isExist;\r\n    }\r\n\r\n    struct Seller {\r\n        address sellerAddress;\r\n        string sellerName;\r\n        uint256 sellerID;\r\n        bool isExist; //flag to determine whether the Seller exists TODO: find a better way\r\n        mapping(uint256 => Product) sellerProducts; //using the productID to obtain the product ; TODO: can we use a string instead?\r\n        uint256 totalProducts;\r\n        uint256 totalRevenue;\r\n        uint256 numOfSales;\r\n    }\r\n\r\n    struct Buyer {\r\n        address buyerAddress;\r\n        string buyerName;\r\n        uint256 buyerID; //TODO: figure out the difference between uint and uint256\r\n        bool isExist; //flag to determine whether the buyer exists TODO: figure out a better way\r\n        mapping(uint256 => Transaction) txnMade;\r\n        uint256 numOfTxn;\r\n        uint256 numOfReviewsGiven;\r\n    }\r\n\r\n    //----- Mappings -----\r\n\r\n    //Maps user address to Seller or Buyer account structs\r\n    // TODO: can we merge this with the object itself?\r\n    // Mapping buyerAddress to array of Products that they bought\r\n    // mapping(address => Product[]) public buyerPurchasedProducts;\r\n\r\n    mapping(address => Seller) public sellersList;\r\n    mapping(address => Buyer) public buyersList;\r\n\r\n    //-----Events -----\r\n    event createSellerEvent(\r\n        string sellerName,\r\n        address sellerAddress,\r\n        uint256 sellerID\r\n    );\r\n    event createBuyerEvent(\r\n        string buyerName,\r\n        address buyerAddress,\r\n        uint256 buyerID\r\n    );\r\n    event uploadProductEvent(\r\n        string productName,\r\n        uint256 price,\r\n        uint256 productID,\r\n        address sellerAddress,\r\n        uint256 sellerID\r\n    );\r\n    event purchasedProductsEvent(\r\n        uint256 txnID,\r\n        uint256 productID,\r\n        address sellerAddress,\r\n        address buyerAddress,\r\n        uint256 price\r\n    );\r\n\r\n    function createSeller(string memory _sellerName) public {\r\n        require(\r\n            !sellersList[msg.sender].isExist,\r\n            \"Seller with this wallet already exists! \"\r\n        );\r\n        Seller storage newSeller = sellersList[msg.sender]; //get the object\r\n        //set the variables\r\n        newSeller.sellerAddress = msg.sender;\r\n        newSeller.sellerName = _sellerName;\r\n        newSeller.sellerID = ++totalSellers;\r\n        newSeller.isExist = true;\r\n        newSeller.totalProducts = 0;\r\n        newSeller.totalRevenue = 0;\r\n        newSeller.numOfSales = 0;\r\n\r\n        // sellersList[msg.sender] = newSeller;\r\n        emit createSellerEvent(\r\n            newSeller.sellerName,\r\n            newSeller.sellerAddress,\r\n            newSeller.sellerID\r\n        );\r\n    }\r\n\r\n    function createBuyer(string memory _buyerName) public {\r\n        require(\r\n            !buyersList[msg.sender].isExist,\r\n            \"Buyer with this wallet already exists! \"\r\n        );\r\n        Buyer storage newBuyer = buyersList[msg.sender]; //get the object\r\n        //set the variables\r\n        newBuyer.buyerAddress = msg.sender;\r\n        newBuyer.buyerName = _buyerName;\r\n        newBuyer.buyerID = ++totalBuyers;\r\n        newBuyer.isExist = true;\r\n        newBuyer.numOfReviewsGiven = 0;\r\n        newBuyer.numOfTxn = 0;\r\n\r\n        emit createBuyerEvent(\r\n            newBuyer.buyerName,\r\n            newBuyer.buyerAddress,\r\n            newBuyer.buyerID\r\n        );\r\n    }\r\n\r\n    function uploadProduct(string memory _productName, uint256 price) public {\r\n        //only the currently connected wallet + must be registered seller can create products\r\n        require(\r\n            sellersList[msg.sender].isExist,\r\n            \"Seller with this wallet does not exists! \"\r\n        );\r\n\r\n        Seller storage currentSeller = sellersList[msg.sender]; //TODO: why is it storage?\r\n\r\n        Product storage newProduct = currentSeller.sellerProducts[\r\n            currentSeller.totalProducts\r\n        ];\r\n\r\n        newProduct.productID = currentSeller.totalProducts;\r\n        newProduct.productName = _productName;\r\n        newProduct.sellerAddress = msg.sender;\r\n        newProduct.productPrice = price;\r\n        newProduct.totalSold = 0;\r\n        newProduct.isExist = true;\r\n\r\n        currentSeller.sellerProducts[currentSeller.totalProducts] = newProduct;\r\n        currentSeller.totalProducts++;\r\n\r\n        emit uploadProductEvent(\r\n            newProduct.productName,\r\n            newProduct.productPrice,\r\n            newProduct.productID,\r\n            newProduct.sellerAddress,\r\n            currentSeller.sellerID\r\n        );\r\n    }\r\n\r\n    function purchaseProduct(\r\n        uint256 productID,\r\n        address payable sellerAddress\r\n    ) public payable {\r\n        require(buyersList[msg.sender].isExist, \"This buyer does not exist!\");\r\n        require(\r\n            sellersList[sellerAddress].sellerProducts[productID].isExist,\r\n            \"The Product does not exist!\"\r\n        );\r\n        require(\r\n            msg.value ==\r\n                sellersList[sellerAddress]\r\n                    .sellerProducts[productID]\r\n                    .productPrice,\r\n            \"Ethers not enough/too much to buy the product!\"\r\n        );\r\n\r\n        //TODO: figure out the gas txn fee\r\n\r\n        (bool callSuccess, ) = sellerAddress.call{value: msg.value}(\"\");\r\n        require(callSuccess, \"Failed to send ether\");\r\n\r\n        uint256 txnID = buyersList[msg.sender].numOfTxn;\r\n\r\n        Transaction storage newTxn = buyersList[msg.sender].txnMade[txnID];\r\n        newTxn.txnID = txnID;\r\n        newTxn.timeStamp = block.timestamp;\r\n        newTxn.purchasedProduct = sellersList[sellerAddress].sellerProducts[\r\n            productID\r\n        ]; //push the sellers product into the transaction list\r\n        newTxn.reviewed = false;\r\n        newTxn.isExist = true;\r\n        buyersList[msg.sender].txnMade[txnID] = newTxn;\r\n        buyersList[msg.sender].numOfTxn++;\r\n\r\n        sellersList[sellerAddress].sellerProducts[productID].totalSold++;\r\n        sellersList[sellerAddress].totalRevenue += msg.value;\r\n        sellersList[sellerAddress].numOfSales += 1;\r\n\r\n        emit purchasedProductsEvent(\r\n            txnID,\r\n            productID,\r\n            sellerAddress,\r\n            msg.sender,\r\n            sellersList[sellerAddress].sellerProducts[productID].productPrice\r\n        );\r\n    }\r\n\r\n    function buyerReview(uint256 buyerRating, uint256 txnID) public {\r\n        require(buyersList[msg.sender].isExist, \"This buyer does not exist!\");\r\n\r\n        require(\r\n            buyersList[msg.sender].txnMade[txnID].isExist,\r\n            \"Buyer does not have this transaction ID\"\r\n        );\r\n\r\n        address sellerAddress = buyersList[msg.sender]\r\n            .txnMade[txnID]\r\n            .purchasedProduct\r\n            .sellerAddress;\r\n        uint256 productID = buyersList[msg.sender]\r\n            .txnMade[txnID]\r\n            .purchasedProduct\r\n            .productID;\r\n        sellersList[sellerAddress].sellerProducts[productID].review =\r\n            ((buyersList[msg.sender].txnMade[txnID].purchasedProduct.review *\r\n                buyersList[msg.sender]\r\n                    .txnMade[txnID]\r\n                    .purchasedProduct\r\n                    .numOfReviewsGiven) + buyerRating) /\r\n            (buyersList[msg.sender]\r\n                .txnMade[txnID]\r\n                .purchasedProduct\r\n                .numOfReviewsGiven + 1);\r\n\r\n        buyersList[msg.sender]\r\n            .txnMade[txnID]\r\n            .purchasedProduct\r\n            .numOfReviewsGiven++;\r\n    }\r\n\r\n    /* View and Pure Functions */\r\n\r\n    function retrieveTotalBuyers() public view returns (uint256) {\r\n        return totalBuyers;\r\n    }\r\n\r\n    function retrieveTotalSellers() public view returns (uint256) {\r\n        return totalSellers;\r\n    }\r\n\r\n    function viewProductPrice(\r\n        address _sellerAddress,\r\n        uint256 _productID\r\n    ) public view returns (uint256) {\r\n        //check whether the seller exists\r\n        require(\r\n            sellersList[_sellerAddress].isExist,\r\n            \"Seller with this wallet does not exists! \"\r\n        );\r\n        //check whether the product exists\r\n        require(\r\n            sellersList[_sellerAddress].sellerProducts[_productID].isExist,\r\n            \"Seller with this wallet does not exists! \"\r\n        );\r\n        //return the price\r\n        return\r\n            sellersList[_sellerAddress].sellerProducts[_productID].productPrice;\r\n    }\r\n\r\n    function viewProductSold(\r\n        address _sellerAddress,\r\n        uint256 _productID\r\n    ) public view returns (uint256) {\r\n        //check whether the seller exists\r\n        require(\r\n            sellersList[_sellerAddress].isExist,\r\n            \"Seller with this wallet does not exists! \"\r\n        );\r\n        //check whether the product exists\r\n        require(\r\n            sellersList[_sellerAddress].sellerProducts[_productID].isExist,\r\n            \"ProductID in the seller does not exists! \"\r\n        );\r\n        //return the price\r\n        return sellersList[_sellerAddress].sellerProducts[_productID].totalSold;\r\n    }\r\n\r\n    function viewProductReview(\r\n        address _sellerAddress,\r\n        uint256 _productID\r\n    ) public view returns (uint256) {\r\n        //check whether the seller exists\r\n        require(\r\n            sellersList[_sellerAddress].isExist,\r\n            \"Seller with this wallet does not exists! \"\r\n        );\r\n\r\n        require(\r\n            sellersList[_sellerAddress].sellerProducts[_productID].isExist,\r\n            \"ProductID in the seller does not exists! \"\r\n        );\r\n        //check whether the product exists\r\n        //return the price\r\n        return sellersList[_sellerAddress].sellerProducts[_productID].review;\r\n    }\r\n\r\n    function viewTransactions(\r\n        address _buyerAddress,\r\n        uint256 _txnID\r\n    ) public view returns (uint256) {\r\n        require(\r\n            buyersList[_buyerAddress].isExist,\r\n            \"Seller with this wallet does not exists! \"\r\n        );\r\n\r\n        require(\r\n            buyersList[_buyerAddress].txnMade[_txnID].isExist,\r\n            \"Txn ID in the seller does not exists! \"\r\n        );\r\n        //check whether the product exists\r\n        //return the price\r\n        return\r\n            buyersList[_buyerAddress]\r\n                .txnMade[_txnID]\r\n                .purchasedProduct\r\n                .productID;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}